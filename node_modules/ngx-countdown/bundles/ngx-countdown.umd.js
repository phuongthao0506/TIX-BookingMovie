(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common'),exports, require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-countdown', ['@angular/core','@angular/common','exports', '@angular/core', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ng.core,global.ng.common,global['ngx-countdown'] = {}, global.ng.core, global.ng.common));
}(this, (function (ɵngcc0,ɵngcc1,exports, i0, common) { 
function CountdownComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "span", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r0.i.text, ɵngcc0.ɵɵsanitizeHtml);
} }
function CountdownComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
var _c0 = function (a0) { return { $implicit: a0 }; };
'use strict';

    (function (CountdownStatus) {
        CountdownStatus[CountdownStatus["ing"] = 0] = "ing";
        CountdownStatus[CountdownStatus["pause"] = 1] = "pause";
        CountdownStatus[CountdownStatus["stop"] = 2] = "stop";
        CountdownStatus[CountdownStatus["done"] = 3] = "done";
    })(exports.CountdownStatus || (exports.CountdownStatus = {}));

    var CountdownTimer = /** @class */ (function () {
        function CountdownTimer(ngZone) {
            this.ngZone = ngZone;
            this.fns = [];
            this.commands = [];
            this.ing = false;
        }
        CountdownTimer.prototype.start = function () {
            var _this = this;
            if (this.ing === true) {
                return;
            }
            this.ing = true;
            this.nextTime = +new Date();
            this.ngZone.runOutsideAngular(function () {
                _this.process();
            });
        };
        CountdownTimer.prototype.process = function () {
            var _this = this;
            while (this.commands.length) {
                this.commands.shift()();
            }
            var diff = +new Date() - this.nextTime;
            var count = 1 + Math.floor(diff / 100);
            diff = 100 - (diff % 100);
            this.nextTime += 100 * count;
            for (var i = 0, len = this.fns.length; i < len; i += 2) {
                var frequency = this.fns[i + 1];
                // 100/s
                if (0 === frequency) {
                    this.fns[i](count);
                    // 1000/s
                }
                else {
                    // 先把末位至0，再每次加2
                    frequency += 2 * count - 1;
                    var step = Math.floor(frequency / 20);
                    if (step > 0) {
                        this.fns[i](step);
                    }
                    // 把末位还原成1
                    this.fns[i + 1] = (frequency % 20) + 1;
                }
            }
            if (!this.ing) {
                return;
            }
            setTimeout(function () { return _this.process(); }, diff);
        };
        CountdownTimer.prototype.add = function (fn, frequency) {
            var _this = this;
            this.commands.push(function () {
                _this.fns.push(fn);
                _this.fns.push(frequency === 1000 ? 1 : 0);
                _this.ing = true;
            });
            return this;
        };
        CountdownTimer.prototype.remove = function (fn) {
            var _this = this;
            this.commands.push(function () {
                var i = _this.fns.indexOf(fn);
                if (i !== -1) {
                    _this.fns.splice(i, 2);
                }
                _this.ing = _this.fns.length > 0;
            });
            return this;
        };
CountdownTimer.ɵfac = function CountdownTimer_Factory(t) { return new (t || CountdownTimer)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
CountdownTimer.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CountdownTimer, factory: function (t) { return CountdownTimer.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CountdownTimer, [{
        type: i0.Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
        return CountdownTimer;
    }());
    CountdownTimer.ctorParameters = function () { return [
        { type: i0.NgZone }
    ]; };

    // tslint:disable: no-inferrable-types
    var CountdownGlobalConfig = /** @class */ (function () {
        function CountdownGlobalConfig(locale) {
            var _this = this;
            this.locale = locale;
            this.demand = false;
            this.leftTime = 0;
            this.format = 'HH:mm:ss';
            this.timezone = '+0000';
            this.formatDate = function (_a) {
                var date = _a.date, formatStr = _a.formatStr, timezone = _a.timezone;
                return common.formatDate(new Date(date), formatStr, _this.locale, timezone || _this.timezone || '+0000');
            };
        }
CountdownGlobalConfig.ɵfac = function CountdownGlobalConfig_Factory(t) { return new (t || CountdownGlobalConfig)(ɵngcc0.ɵɵinject(i0.LOCALE_ID)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CountdownGlobalConfig, [{
        type: i0.Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: String, decorators: [{
                type: i0.Inject,
                args: [i0.LOCALE_ID]
            }] }]; }, null); })();
        return CountdownGlobalConfig;
    }());
    CountdownGlobalConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function CountdownGlobalConfig_Factory() { return new CountdownGlobalConfig(i0.ɵɵinject(i0.LOCALE_ID)); }, token: CountdownGlobalConfig, providedIn: "root" });
    CountdownGlobalConfig.ctorParameters = function () { return [
        { type: String, decorators: [{ type: i0.Inject, args: [i0.LOCALE_ID,] }] }
    ]; };

    var CountdownComponent = /** @class */ (function () {
        function CountdownComponent(locale, timer, defCog, cdr, ngZone) {
            this.locale = locale;
            this.timer = timer;
            this.defCog = defCog;
            this.cdr = cdr;
            this.ngZone = ngZone;
            this.frequency = 1000;
            this._notify = {};
            this.status = exports.CountdownStatus.ing;
            this.isDestroy = false;
            this.i = {};
            this.left = 0;
            this.event = new i0.EventEmitter();
        }
        Object.defineProperty(CountdownComponent.prototype, "config", {
            get: function () {
                return this._config;
            },
            set: function (i) {
                if (i.notify != null && !Array.isArray(i.notify) && i.notify > 0) {
                    i.notify = [i.notify];
                }
                this._config = i;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Start countdown, you must manually call when `demand: false`
         */
        CountdownComponent.prototype.begin = function () {
            this.status = exports.CountdownStatus.ing;
            this.callEvent('start');
        };
        /**
         * Restart countdown
         */
        CountdownComponent.prototype.restart = function () {
            if (this.status !== exports.CountdownStatus.stop) {
                this.destroy();
            }
            this.init();
            this.callEvent('restart');
        };
        /**
         * Stop countdown, must call `restart` when stopped, it's different from pause, unable to recover
         */
        CountdownComponent.prototype.stop = function () {
            if (this.status === exports.CountdownStatus.stop) {
                return;
            }
            this.status = exports.CountdownStatus.stop;
            this.destroy();
            this.callEvent('stop');
        };
        /**
         * Pause countdown, you can use `resume` to recover again
         */
        CountdownComponent.prototype.pause = function () {
            if (this.status === exports.CountdownStatus.stop || this.status === exports.CountdownStatus.pause) {
                return;
            }
            this.status = exports.CountdownStatus.pause;
            this.callEvent('pause');
        };
        /**
         * Resume countdown
         */
        CountdownComponent.prototype.resume = function () {
            if (this.status === exports.CountdownStatus.stop || this.status !== exports.CountdownStatus.pause) {
                return;
            }
            this.status = exports.CountdownStatus.ing;
            this.callEvent('resume');
        };
        CountdownComponent.prototype.callEvent = function (action) {
            this.event.emit({ action: action, left: this.left, status: this.status, text: this.i.text });
        };
        CountdownComponent.prototype.init = function () {
            var _this = this;
            var _a = this, locale = _a.locale, defCog = _a.defCog;
            var config = (this.config = Object.assign(Object.assign(Object.assign({}, new CountdownGlobalConfig(locale)), defCog), this.config));
            // tslint:disable-next-line: no-bitwise
            var frq = (this.frequency = ~config.format.indexOf('S') ? 100 : 1000);
            this.status = config.demand ? exports.CountdownStatus.pause : exports.CountdownStatus.ing;
            this.getLeft();
            // bind reflow to me
            var _reflow = this.reflow;
            this.reflow = function (count, force) {
                if (count === void 0) { count = 0; }
                if (force === void 0) { force = false; }
                return _reflow.apply(_this, [count, force]);
            };
            if (Array.isArray(config.notify)) {
                config.notify.forEach(function (time) {
                    if (time < 1) {
                        throw new Error("The notify config must be a positive integer.");
                    }
                    time = time * 1000;
                    time = time - (time % frq);
                    _this._notify[time] = true;
                });
            }
            this.timer.add(this.reflow, frq).start();
            this.reflow(0, true);
        };
        CountdownComponent.prototype.destroy = function () {
            this.timer.remove(this.reflow);
            return this;
        };
        /**
         * 更新时钟
         */
        CountdownComponent.prototype.reflow = function (count, force) {
            var _this = this;
            if (count === void 0) { count = 0; }
            if (force === void 0) { force = false; }
            if (this.isDestroy) {
                return;
            }
            var _a = this, status = _a.status, config = _a.config, _notify = _a._notify;
            if (!force && status !== exports.CountdownStatus.ing) {
                return;
            }
            var value = (this.left = this.left - this.frequency * count);
            if (value < 1) {
                value = 0;
            }
            this.i = {
                value: value,
                text: config.formatDate({ date: value, formatStr: config.format, timezone: config.timezone }),
            };
            if (typeof config.prettyText === 'function') {
                this.i.text = config.prettyText(this.i.text);
            }
            this.cdr.detectChanges();
            if (config.notify === 0 || _notify[value]) {
                this.ngZone.run(function () {
                    _this.callEvent('notify');
                });
            }
            if (value === 0) {
                this.ngZone.run(function () {
                    _this.status = exports.CountdownStatus.done;
                    _this.destroy();
                    _this.callEvent('done');
                });
            }
        };
        /**
         * 获取倒计时剩余帧数
         */
        CountdownComponent.prototype.getLeft = function () {
            var _a = this, config = _a.config, frequency = _a.frequency;
            var left = config.leftTime * 1000;
            var end = config.stopTime;
            if (!left && end) {
                left = end - new Date().getTime();
            }
            this.left = left - (left % frequency);
        };
        CountdownComponent.prototype.ngOnInit = function () {
            this.init();
            if (!this.config.demand) {
                this.begin();
            }
        };
        CountdownComponent.prototype.ngOnDestroy = function () {
            this.isDestroy = true;
            this.destroy();
        };
        CountdownComponent.prototype.ngOnChanges = function (changes) {
            if (!changes.config.firstChange) {
                this.restart();
            }
        };
CountdownComponent.ɵfac = function CountdownComponent_Factory(t) { return new (t || CountdownComponent)(ɵngcc0.ɵɵdirectiveInject(i0.LOCALE_ID), ɵngcc0.ɵɵdirectiveInject(CountdownTimer), ɵngcc0.ɵɵdirectiveInject(CountdownGlobalConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
CountdownComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CountdownComponent, selectors: [["countdown"]], hostVars: 2, hostBindings: function CountdownComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("count-down", true);
    } }, inputs: { config: "config", render: "render" }, outputs: { event: "event" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 5, consts: [[4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"]], template: function CountdownComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CountdownComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, CountdownComponent_ng_container_1_Template, 1, 0, "ng-container", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.render);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.render)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(3, _c0, ctx.i));
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CountdownComponent, [{
        type: i0.Component,
        args: [{
                selector: 'countdown',
                template: "\n    <ng-container *ngIf=\"!render\">\n      <span [innerHTML]=\"i.text\"></span>\n    </ng-container>\n    <ng-container *ngTemplateOutlet=\"render; context: { $implicit: i }\"></ng-container>\n  ",
                host: { '[class.count-down]': 'true' },
                encapsulation: i0.ViewEncapsulation.None,
                changeDetection: i0.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: String, decorators: [{
                type: i0.Inject,
                args: [i0.LOCALE_ID]
            }] }, { type: CountdownTimer }, { type: CountdownGlobalConfig }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }]; }, { event: [{
            type: i0.Output
        }], config: [{
            type: i0.Input
        }], render: [{
            type: i0.Input
        }] }); })();
        return CountdownComponent;
    }());
    CountdownComponent.ctorParameters = function () { return [
        { type: String, decorators: [{ type: i0.Inject, args: [i0.LOCALE_ID,] }] },
        { type: CountdownTimer },
        { type: CountdownGlobalConfig },
        { type: i0.ChangeDetectorRef },
        { type: i0.NgZone }
    ]; };
    CountdownComponent.propDecorators = {
        config: [{ type: i0.Input }],
        render: [{ type: i0.Input }],
        event: [{ type: i0.Output }]
    };

    var CountdownModule = /** @class */ (function () {
        function CountdownModule() {
        }
CountdownModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CountdownModule });
CountdownModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function CountdownModule_Factory(t) { return new (t || CountdownModule)(); }, providers: [CountdownTimer], imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CountdownModule, { declarations: [CountdownComponent], imports: [ɵngcc1.CommonModule], exports: [CountdownComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CountdownModule, [{
        type: i0.NgModule,
        args: [{
                imports: [common.CommonModule],
                providers: [CountdownTimer],
                declarations: [CountdownComponent],
                exports: [CountdownComponent]
            }]
    }], function () { return []; }, null); })();
        return CountdownModule;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.CountdownComponent = CountdownComponent;
    exports.CountdownGlobalConfig = CountdownGlobalConfig;
    exports.CountdownModule = CountdownModule;
    exports.CountdownTimer = CountdownTimer;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngx-countdown.umd.js.map